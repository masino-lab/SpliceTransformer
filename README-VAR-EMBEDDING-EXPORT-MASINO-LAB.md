This file details the information flow and process execution in SpliceTranformer when processing an input variant. It also includes details on changes made to the SpliceTransformer code to support storing the variant embedding generated by the SpliceTransformer Encoder to a file for use in other applications. NOTE: This is only implemented for the `model.`

Note, for a single input variant, v, the SpliceTransformer Encoder generates a [1:192:CW+1] tensor where CW is the reference sequence context, typically CW = 8200. The code modifications detailed here identify the location of v within the CW+1 context, and extract a 1-D tensor of 192 elements representing the embedding for v. 

# Running SpTransformer and Saving Embeddings
This workflow assumes:
- SpTranformer.py is run from the command line
- Variants of interest are stored in file with columns: ID, CHROM, POS, REF, ALT 
  where ID is an arbitrary ID for the sample, CHROM is the chromosome, POS is the variant position on the chromosome, REF is the reference genome allele, and ALT is the alternate allele (i.e., the variant)
- Only SNP variants are supported (this will be updated)
- The output embeddings will be stored in the directory PROJECT_DIR/data/embeddings
  where PROJECT_DIR is your SpliceTransformer repository directory. One file is store for each sample in the input file

The command to run SpliceTransformer and save the embeddings is:

python sptransformer.py --input data/clinvar/clinvar_sample.csv --output data/clinvar/clinvar_sample.tsv --reference hg38 --vcf csv --svemb yes

Note the --svemb argument which was added to SpliceTransformers existing input arguments. Setting it to 'yes' causes the embeddings to be saved. If any other value is passed, the embeddings will not be saved. The default is 'no'. 

# SpliceTransformer Information Flow and Process Execution

Below is an outline of the steps that ocurr when processing variants with SpliceTransformer. It also includes information about the code and where the original code was modified (noted by a \#). This description assumes you are running SpliceTransformer/sptransformer.py from a command line with input file as described above. The process starts with the `if __name__ == '__main__':` in sptransformer.py which parses the command line input arguments and calls the function Annotator.annotate_variant_table in sptransformer.py. From there, the following steps occur (these are not all inclusive, only those relevant to storing the embeddings are noted)

TL;DR
The short version is that the following sequence of methods calls are made to process a variant. The code for each of these methods has been modified to enable optional variant embedding storage. Detailed discussion follows below:
1. Annotator.annotate_variant_table in sptransformer.py
2. Annotator.query_scores in sptransformer.py
3. SpTransformerDriver.calc_snp_misaligned in tasks_annotate_mutations.py
4. SNPInterval.parse in tasks_annotate_mutations.py
5. ModelDriver.calc_single_sequence in tasks_annotate_mutations.py
6. ModelDriver.step in tasks_annotate_mutations.py
7. SpTransformer.forward in model/model.py


## Step 1
Annotator.annotate_variant_table in sptransformer.py:
  - iterates over each row in the input file
  - loads a single sample into a variable called `record`
  - calls self.query_scores \# this method call was modified to add inputs `record_id` and `save_var_embeddings`

## Step 2
Annotator.query_scores in sptransformer.py
  - \# the method signature was modified to include inputs `record_id` and `save_var_embeddings` with defalut values of None and False
  - calls `self.get_genes` which returns 'strands'. Basically, `get_genes` uses pyensemble to get the gene strands for this variant. NOTE: Pyensemble may return multiple strands for a single variant. This can happen for a variety of reaons.
  - `for strand in strands`:
      - \# a new variable `record` is created. It is a dictionary with information on the variant. It includes the keys: chrom, pos, ref, alt, ref_genome, strand, id, save_var_embeddings.
      - calls `self.model.calc_snp_misaligned` \# Currently the self.model is an instance of SpTransformerDriver. This call was modified to add `record` to the inputs

## Step 3A
SpTransformerDriver.calc_snp_misaligned in tasks_annotate_mutations.py
  - calls snp.parse \# snp is an instance of tasks_annotate_mutations.SNPInterval. 

## Step 4
SNPInterval.parse in tasks_annotate_mutations.py
  - This builds the context window for the variant
  - The code for the alt sequence is `seq_alt = seq_ref[:offset] + str(self.alt) + seq_ref[offset+len(self.ref):]`
  - This means that the variant is in `seq_alt[offset:offset+len(self.ref]` We will need this to access the variant position in the embedding tensor. The code for this method has been modified to return the offset value.

## Step 3B
SpTransformerDriver.calc_snp_misaligned in tasks_annotate_mutations.py
  - after step 3A, this method now has the `offset` value from snp.parse
  - \# `offset` variable is added to the `record` variable
  - calls `self.calc_single_sequence` \# NOTE this is called for the ref allele AND the alt allele (i.e., the variant). The code is modified for the alt allele call in which the `record` variable is passed in.

## Step 5
ModelDriver.calc_single_sequence in tasks_annotate_mutations.py
  - ModelDriver class is a base class for different models
  - The `calc_single_sequence` method calls `self.step` \# This method was modifed to take the `record` variable as input and pass it to `self.step`

## Step 6
ModelDriver.step in tasks_annotate_mutations.py
  - ModelDriver class is a base class for different models
  - The `step` method calls the `forward` method for all models in the ModelDriver instance. This method was modified to pass the `record` variable into the `forward` calls.

## Step 7
SpTransformer.forward in model/model.py
  - \# this method was modified to take the `record` argument. NOTE: All models in model.py were modified to accept the `record` input, BUT only the SpTransformer model was updated to actually process the record.
  - The variant embedding is stored in the `feat1` variable which is a 3D tensor [batch, embedding_dim, seq_context]. We only want an [embedding_dim] tensor. The updated code extracts this using the information in `record`. It is stored in `./data/embeddings/FN` where FN is: `id_{record['id']}_rg_{record['ref_genome']}_{record['chrom']}_pos_{record['pos']}_ref_{record['ref']}_alt_{record['alt']}_strand_{record['strand']}.pt`
  